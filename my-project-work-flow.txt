*DOCTOR APPOINTMENT BOOKING*
----------------------------


(First day)---------------------------------->>>>>>>>>>>>>>>>>>>>>>>>>>>


1.created spring starter web project  

added  dependency firstly 

spring web
MySQL 
spring data jpa
Eureka Discovery Client (port no 9761)


2.Opened File in IntelliJ

3.Created basic Package 
                      
                      1.Entity    ->
                                   
                                    a.Doctor
                                    b.State   (Mapped ManyToOne and added join column
                                              in Doctor and made a foregin Key because
                                               many doctor belongs to one State)

                                    c.City (same mapping) 
                                    d.Area (same mapping)


                      2.Repository  ->
                                               a. DoctorRepositroy (added the @Query to find the doctor based
                                                                    on city or specialization)
                                               b. StateRepository
                                               c. AreaRepository
                                               d. CityRepository
                      3.Service
                      4.controller

4.Added MySQL properties Jpa Properties Hibernate Properties in Application.properties file.. add server.port=8081
5.Run the main class and table has created in local database.



                                            2nd Day
                                   -----------------------------

Search Operation for the Doctor..
----------------------------------
1.manually open the database 
and add 3-4 data the details in all the table   and in URL section gave dummy url right now.. click apply .

now search should be based on City and area both .
add city and area both query to find in Doctor Repository.

2.Create a SearchController in controller package. and added @RestController and @RequestMapping("/api/v1/doctor")

   @GetMapping("/search")
3. added ResponseEntity that will give List of doctors. and added @RequestParam String specialization 
                                                                 @RequestParam String area

4. Autowired the DoctorRepository.

search
//http://localhost:8080/api/v1/doctor/search?specialization=cardiologist&areaName=BTM


=================================================================================================================================== 


2nd MicroService (Patient) 
Now Patient will Search the Doctor and he'll do the Booking..

--------------------------------------------------------------------

1.Create Spring starter web Project 
                                   
                                   group - com.patient-service
                                   artifactid - patient-service
                                   Name- patient-service
                                   package- com.patient-service..

2. package            1.Entity    ->
                                   
                                    a.Patient
                                    b.State   (Mapped ManyToOne and added join column
                                              in Patient and made a foregin Key because
                                               many Pateint belongs to one State)

                                    c.City (same mapping) 
                                    d.Area (same mapping)


                      2.Repository  ->
                                               a. PatientRepositroy                                                                  
                    
                      3.service
                      4.controller
                      5.exception




notes
----
Relation between doctor and appointment schedule  -> one doctor can have appointment on many date.

and One Date can have multiple time slots.......   

Relationship tree
------------------------------------------                  
           Doctor
                  |
                   ---DoctorAppointmentSchedule(date) 
                              |
                               ------TimeSlots(time)

we have done bidirectional mapping that everyone knows eachother.........

to stop the recursive action to avoid unlimited details ..
we ll use jsonbackreference and jsonmanagereference

to search for the Doctor based on dates and times we will build

in Doctor-service entity package
                              1.DoctorAppointmentSchedule  class   this will have LocalDate date;
                              2.TimeSlots  class   this will have LocalTime time;


The Patient will search the doctor he'll sign up
for that we build patient service microservice ...........
we added the port no 8082 and another patient_db we created..

Now the logic is 

               One doctor will have many patient 
               and one patient will have manydoctors.       manytomany relation..


but we are using microservice so we can easily avoid this conflicts ..by using appointment-service

Now we are using sql join to obtain the matching records from the doctor , doctorappointmentschedule and timeslots..
Inner join we'll use the which will give matching records from both the table;

so when we do bidirectional mapping whichever table that they know it will fetch all the details.

http://localhost:8081/api/v1/doctor/search?specialization=cardiologist&areaName=BTM

[
  {
    "id": 1,
    "name": "sujith",
    "specialization": "Cardiologist",
    "qualification": "MBBS",
    "contact": "9883290711",
    "experiance": "11",
    "url": "http://xyz.com",
    "address": "No. 6, 100 feet road",
    "state": {
      "id": 1,
      "name": "Karnataka"
    },
    "city": {
      "id": 1,
      "name": "Bengaluru"
    },
    "area": {
      "id": 1,
      "name": "BTM"
    },
    "appointmentSchedules": [
      {
        "id": 1,
        "date": "2025-10-30",
        "timeSlots": [
          {
            "id": 1,
            "time": "11:00:00"
          },
          {
            "id": 2,
            "time": "11:30:00"
          }
        ]
      },
      {
        "id": 2,
        "date": "2025-10-31",
        "timeSlots": []
      }
    ]
  },
  {
    "id": 2,
    "name": "ajay",
    "specialization": "Cardiologist",
    "qualification": "MBBS",
    "contact": "96289009415",
    "experiance": "15",
    "url": "http://abc.com",
    "address": "No.272, 100 feet road",
    "state": {
      "id": 1,
      "name": "Karnataka"
    },
    "city": {
      "id": 1,
      "name": "Bengaluru"
    },
    "area": {
      "id": 1,
      "name": "BTM"
    },
    "appointmentSchedules": [
      {
        "id": 3,
        "date": "2025-10-31",
        "timeSlots": [
          {
            "id": 3,
            "time": "12:30:00"
          }
        ]
      }
    ]
  }
]  output looks like this..................................................


===========================================================================================================================

Day-3 

Applied current and future date concept in search Controller .
--------------------------------------------------------------
by using LocalTime .
isEqual()  method =current time
iAfter()  = future time
isBefore()= previous time.

because patient will search only the future or current time..................


Day-4
-----------------------------------------------------------------------------------------------------------------------                     
-----------------------------------------------------------------------------------------------------------------------


now added eureka  microservice with dependency added eureka discovery.

now in application.properties added
server.port=8761
eureka.client.register-with-eureka=false
eureka.client.fetch-registry=false


now in main application of eureka 
added
@EnableEurekaServer

and run the Eureka Application.
after running started doctor-service and patient-service application to add in Eureka Server.


Now .............

created booking-service microservice 
added dependencies-
                   openFiegn  - to intercommunicate between the patientservice to doctor service and payment gateway.
                   EurekaDiscoveryClient
                   spring web
                   spring data jpa
                   spring Boot dev tools
                   MySQL Driver


EnabledDiscoveryClient to add the service with Eureka

now in doctor-service 

in searchController

create a method to get the doctor details.. it will directly return doctor details not in response or json.

//http://localhost:8080/api/v1/doctor/getdoctorbyid?id=1
getMapping("/getdoctorid) ..................


now from bookingcontroller i will call the method .
for that we need to @Enableopenfiegnclient in booking-service application.

feign client is  used to call one microservice from another microservice..

now created doctorfiegnclient interface

@FeignClient(name = "doctor-service",url = "http://localhost:8081/api/v1/doctor")
public interface DoctorClient {
      
        @GetMapping("/getdoctorbyid")
        Doctor getDoctorById(@RequestParam long id);             this is the same method where you created in Doctor-Service in controller.

}

created Doctor dto in dto pacage and added all the information simply copy pasted and removed unwanted annotation...

here Doctor is the Dto of dto pacage.


now from BookingController created a method to getthedoctorbyid

       @Autowired
       private DoctorClient doctorClient;

    //http://localhost:8085/api/v1/booking/getdoctor?id=1
            @GetMapping("/getdoctor")
            public Doctor getDoctorById(@RequestParam long id)
            {
                return doctorClient.getDoctorById(1);
            }

start all your service first and run..

..........................................................
                   
5th Day
===========================================================================================================================
in Booking controller

in every doctor details one book button will be there. 
now suppose. moment you click on booking button then two things will go to the backend.
1.doctorid
2.patientid

we need actual doctor from database that why we have changed the parameter to actual doctorId.

now we have added @RequestParam long patientId in the getdoctorbyid method ..
and also  changed the getmapping url and added &patientId=1

.............................................................................................................
Now we need to create a PatientController class
and get the patientbyid details object directly...

 @GetMapping("/getpatientbyid)
        public Patient getPatientById(@Requestparam long id)
        {
            return patientRepository.findById(id).get();
        }
            

after getting the patientobject.
we have bulid a patientclient interface in our booking-service annotated with @FeignClients(name="patient-service",url="with patient service port) 


 @GetMapping("/getpatientbyid")
    public Patient getPatientById(@RequestParam long id);


now we require patientDto. because whatever response we get .we have to store somewhere.
created dto package and just copied the entity of patient from patient-service to dto of booking-service.

and removed all the annotations.
and imports.

after that in bookingcontroller. when clicking on book button both doctor and patient details required so 
for now we are returning the value in String.
stored both doctor in d var 
and patient in p var.

started and running all the services.


=======================================================================================================================================

Day -6 
=========================================================================================================================================
Create payment-service maven microservice and added 
dependencies-> spring web 
             ->  Eureka Discovery CLient
              -> Stripe Dependency

Stripe -We are using now for testing purpose
=======
Stripe is a payment gateway ‚Äî a platform that lets you accept online payments safely and easily.
It handles all the hard parts like:
talking to banks and credit card networks,
ensuring security and encryption,
managing refunds, subscriptions, invoices, etc.

Once we logged in to the account.
->>>>>>>> Copy the Secret Key.

Created Dto Package
===================
added        -> ProductRequest class     -  
             -> StripeResponse class
what is ProductRequest?
ProductRequest is a Data Transfer Object (DTO) ‚Äî
a simple Java class that represents what data the API needs from the client when creating a Stripe checkout session.
public class ProductRequest {
    private Long amount;
    private long quantity;
    private String name;
    private String currency;
    // getters & setters
}

StripeResponse
==============
public class StripeResponse {

    private String status;
    private String message;
    private String sessionId;
    private String sessionUrl;
}

If ProductRequest is the input, then StripeResponse is the output.

When you call your backend endpoint (like /create-checkout-session):
You send a request with details (‚Üí ProductRequest)
The backend calls Stripe API
Stripe sends back a response with info like payment URL, session ID, status, etc.
Your backend then sends that info to the frontend (‚Üí StripeResponse)
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Service Package
==============
create StripeService
set the secretKey with adding @Value annotation. which takes the value from application.properties file where we set
spring.application.name=payment-service
server.port=5555
stripe.secretKey=sk_test_**********************************8

üîç Step-by-step explanation
============================
| Step                         | What happens                                     | Example                               |
| ---------------------------- | ------------------------------------------------ | ------------------------------------- |
| **1Ô∏è‚É£ Set API Key**          | Stripe SDK needs your secret key to authenticate | `Stripe.apiKey = "sk_test_..."`       |
| **2Ô∏è‚É£ Build Session Params** | You tell Stripe what the user is buying          | name, amount, currency                |
| **3Ô∏è‚É£ Create Session**       | Stripe returns a secure payment page URL         | `https://checkout.stripe.com/pay/...` |
| **4Ô∏è‚É£ Return Response**      | You wrap it in `StripeResponse` for frontend     | includes `sessionId` + `sessionUrl`   |

the Service will create unique session for every payment req .
when user will click on Checkout.. User get the option to make proceed with payment along with the productdetails.that we set.
then the payment.Mode will come and it will get stored in params variable.  
now when you are in paymentmode for that one session id will be created
once you click on submit you get a paymentUrl with afterclickon it .. u get success msg after completion.

-----------------------------------------------------------------------------------------------------------
Created ProductCheckoutController
---------------------------------
@RestController
@RequestMapping("/product/v1")
public class ProductCheckoutController {

    @Autowired
    private StripeService stripeService;

    @PostMapping("/checkout")
    public ResponseEntity<StripeResponse> checkoutProducts(@RequestBody ProductRequest  productRequest)
    {
      StripeResponse stripeResponse=  stripeService.checkoutProducts(productRequest);
       return ResponseEntity
               .status(HttpStatus.OK)
               .body(stripeResponse);


    }
}
=================================================================================================================================
after that use postman body
{
   "amount":50000,
   "quantity":2,
   "name":"nike shoes",
   "currency":"USD"

}
you will get url click and add card details ..... 4242 4242 4242 4242   05/28 / 846      -> submit

====================================================================================================================================
Day-7        -Updation of Booking Details if the payment is successful
Payment Success Message. in Controller we are going to do.
 

In Booking-service 
created a BookingConfirmation class in entity package . and gave the details which i want after payment success.in page.

Now in BookingController.
   @GetMapping("/getdoctor")
            public String getDoctorById(
                    @RequestParam long doctorId,
                    @RequestParam long patientId,
                    @RequestParam LocalDate date,
                    @RequestParam LocalTime time)

comparing date and time and if availave then booking happens.  for that if added manually in appointmentschwduledb todays data and timeslots......
we added if condition  using equals() to match the date and time.  
 
List<DoctorAppointmentSchedule> appointmentSchedules = d.getAppointmentSchedules();
        for (DoctorAppointmentSchedule app : appointmentSchedules) {
            LocalDate localDate = app.getDate();
            if (localDate.isEqual(date)) {
                List<TimeSlots> timeSlots = app.getTimeSlots();
                for (TimeSlots t : timeSlots) {
                    if (timeSlots.equals(time)) {
                        System.out.println("Complete Booking");
                    }
                }
            }
           
        }

========================================================

Day -8
===========================================================
In Appointment schedule added data for todays 
in timeslots added for todays data.


now we'll build a URL  that will have local date and time.. 

http://localhost:8085/api/v1/booking/getdoctor?doctorId=1&patientId=1&date=2025-11-18&time=14:30

->if the date and timeslots matches with the url we'll get message in console complete booking and in postman "done" we get.

here we did'not get the complete booking message. 
You are not getting ‚ÄúComplete Booking‚Äù because your condition is wrong.
You wrote this----
if (timeSlots.equals(time)) {

‚ùå This is incorrect because:
timeSlots = List<TimeSlots>
time = LocalTime

You are comparing a list to a LocalTime, which will always return false.
‚úÖ Correct Condition
Inside your loop you should compare:

if (t.getTime().equals(time)) {
    System.out.println("Complete Booking");
}


Because:
t is one individual time slot
t.getTime() returns LocalTime
time is your input LocalTime
So they can be compared.


now we set the booking date and time after comparing .. and also set the docter address and patient name in bookingconfirmation
if (t.getTime().equals(time))   //t.getTime() returns LocalTime and  time is your input LocalTime
                    {
                         bookingConfirmation.setDate(date);
                         bookingConfirmation.setTime(time);

}
}
}
}
here we are saving the bookingconfirmation details in database for that we created BookingCOnfirmationRepository.
for that we inject autowired BookingconfrimationRepositroy.

 bookingConfirmationRepository.save(bookingConfirmation);
return "done"
}
}

//one we done .. In Postman GetMapping use   and send  your data will be saved in Database .
http://localhost:8085/api/v1/booking/getdoctor?doctorId=1&patientId=1&date=2025-11-18&time=14:30
id  Address                 date        nameofdoctor   patient                status    time
1	  No. 6, 100 feet road	2025-11-18    	sujith	        mike                   	0	        14:30:00.000000
						
here the status is false .. when he confirms the payment then status will be true.

=======================================================================================================================



Day -9
Booking Integration we'll do today and once the payment is done w'll do true in status.

in booking-service we created a PaymentClient interface 

@FeignClient(name = "PAYMENT-SERVICE")
public interface PaymentClient {

    @PostMapping("/product/v1/checkout")
    StripeResponse checkout(@RequestBody ProductRequest productRequest);
now we require same   StripeResponse dto and ProductRequest which is in Payment-service  dto -> which should be added in dto package of booking-service
becasuse the return type is json.

.now in BookingController -> inject PaymentClient with autowired

now after saving the bookingconfirmation page
//save booking confirmation
         bookingConfirmationRepository.save(bookingConfirmation);
      
       ProductRequest pr=new ProductRequest();
        pr.setName(bookingConfirmation.getPatientName());
        pr.setAmount(800L);
        pr.setCurrency("INR");
        pr.setQuantity(1L);
        
        paymentClient.checkout(pr);
         return "done";
-------------------------------------------------------------------------------------------
in we want to change the bookingconfirmation status to true instead of printing successful and get the booking details

to get this 
in Payment service  -> inProductRequest we added private long booking and getters and setters

also in Booking-service->dto->ProductRequest also add private long bookingId and getters and setters

now we in bookingController  also set the bookingId.

BookingConfirmation savedBookingConfirmation=  bookingConfirmationRepository.save(bookingConfirmation);  //it ill store the value of booking it will have id.

now 

  ProductRequest pr=new ProductRequest();
        pr.setName(bookingConfirmation.getPatientName());
        pr.setAmount(800L);
        pr.setCurrency("INR");
        pr.setQuantity(1L);
        pr.setBookingId(saveBookingConfirmation.getId());     //here we set .........
        
        paymentClient.checkout(pr);
         return "done";
-------------------------------------------------------------------------------------------------
now after payment completion .
we want a booking confirmation details for that bookingId ;
for that we made a new method  .which will give the details for that booking.

 @GetMapping("/bookingid")
    public BookingConfirmation getBookingById(                   //THIS IS THE METHOD IN BOOKING-CONTROLLER
            @RequestParam long bookingId)
    {
        return bookingConfirmationRepository.findById(bookingId).get();
    }
--------------------------------------------------------------------------------------------------------------------------------


now we require a fiegn client for this method which will call the Payment-Service

so in payment-serivce 
added feign client dependency and added a BookingClient interface ..

@FeignClient(name = "BOOKING-SERVICE")                                    //THIS IS THE CLIENT INERFACE IN  PAYMENT-SERVICE       
                                                                         //CLIENT MEANS HE HAS SOMEONE WHICH WILL CALL IF NEED .. LIKE PAYMENT IS CALLING BOOKING-SERVICE 
                                                                          AND BOOKING-SERVICE WILL CALL THE METHOD AND GET THE DETAILS AND GIVE TO PAYMENT-SERVICE.
public interface BookingClient {
                                           
    @GetMapping("/api/v1/booking/bookingid")
    public BookingConfirmation getBookingById(@RequestParam long bookingId);
}

we  have to get the BookingConfirmation dto inside PaymentService dto..to fetch the details give to json.
BASED ON THE ID IT WILL GIVE THE BOOKING DETAILS 
NOW WE REQUIRE ANOTHER METHOD IN BOOKING-CONTROLLER TO UPDATESTATUS . THE DATABASE AND MAKE THE STATUS TRUE.

 @PutMapping("/updateStatus")
    public void confirmBooking(@RequestBody BookingConfirmation bookingConfirmation)
    {
        bookingConfirmationRepository.save(bookingConfirmation);
    }

we put this method into client of payment-service
which will get the details of booking based on id after payment confirmation . once it the detailed it update the data in database by calling the update method.

so in BookingClient we have two method one will get the details based on id and another will update the data in database
------>>>>>>>>>>>>>>>>>>

@FeignClient(name = "BOOKING-SERVICE")
public interface BookingClient {

    @GetMapping("/api/v1/booking/bookingid")
    public BookingConfirmation getBookingById(@RequestParam long bookingId);

    @PutMapping("/api/v1/booking/updatestatus")
    public void confirmBooking(@RequestBody BookingConfirmation bookingConfirmation);
}

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------

now in Payment-service-> in StriveService
added bookingId
.setSuccessUrl("http://localhost:5555/product/v1/success?session_id={CHECKOUT_SESSION_ID}&bookingId="+productRequest.getBookingId())

this will supply booking id to the controller .
now controller will do @requestparam on bookingId ->

 @GetMapping("/success")
    public ResponseEntity<String> handleSuccess(@RequestParam("session_id") String sessionId,@RequestParam("bookingId") long bookingId) {

now if Paid 
then 
  if ("paid".equalsIgnoreCase(paymentStatus)) {
          BookingConfirmation confirm= client.getBookingById(bookingId);   this will back confirmation object   which have the details of booking 

          confirm.setStatus(true);             setting the status true in BookinngConfirmation after payemntdone.

          client.confirmBooking(confirm)

n





